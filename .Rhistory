ylab="Principal Component 2",
main="PCA on SSW data (Freq missing=15%; 2005 SNPs)")
plot(pca1.0$scores[,1], pca1.0$scores[,2],
cex=2, pch=20, col=gl1$pop,
xlab="Principal Component 1",
ylab="Principal Component 2",
main="PCA on SSW data (Freq missing=15%; 2005 SNPs)")
plot(pca1.0$scores[,1], pca1.0$scores[,2],
cex=2, pch=20, col=gl1$pop,
xlab="Principal Component 1",
ylab="Principal Component 2",
main="PCA on SSW data (Freq missing=15%; 2005 SNPs)")
plot(pca1.0$scores[,1], pca1.0$scores[,2],
cex=2, pch=20, col=gl1.0$pop,
xlab="Principal Component 1",
ylab="Principal Component 2",
main="PCA on SSW data (Freq missing=15%; 2005 SNPs)")
legend("topleft",
legend=unique(gl1.0$pop),
pch=20,
col=c("black", "red"))
plot(pca1.0$scores[,1], pca1.0$scores[,2],
cex=2, pch=20, col=gl1.0$pop,
xlab="Principal Component 1",
ylab="Principal Component 2",
main="PCA on SSW data (Freq missing=15%; 2005 SNPs)")
plot(pca1.0$scores[,1], pca1.0$scores[,2],
cex=2, pch=20, col=gl1.0$pop,
xlab="Principal Component 1",
ylab="Principal Component 2",
main="PCA on SSW data (Freq missing=15%; 2005 SNPs)")
legend("topleft",
legend=unique(gl1.0$pop),
pch=20,
col=c("black", "red"))
unique(gl1.0$pop)
unique
?unique
gl1.0$pop <- ssw_meta$Locality # assign locality info
legend("topleft",
legend=unique(gl1.0$pop),
pch=20,
col=c("black", "red"))
gl1.0$pop <- ssw_meta$Location # assign locality info
vcf1.0 <- read.vcfR("filteredSNPS1.0.recode.vcf")
vcf2.0 <- read.vcfR("filteredSNPS2.0.recode.vcf")
gl1.0 <- vcfR2genlight(vcf1.0)
gl2.0 <- vcfR2genlight(vcf2.0)
ssw_meta <- read.table("ssw_healthloc.txt", header=T) # read in the metadata
ssw_meta <- ssw_meta[order(ssw_meta$Individual),] # sort it by Individual ID
gl1.0$ind.names
ssw_meta$Individual
gl1.0$pop <- ssw_meta$Location # assign locality info
gl1.0$other <- as.list(ssw_meta$Trajectory) # assign disease status
gl2.0$pop <- ssw_meta$Location # assign locality info
gl2.0$other <- as.list(ssw_meta$Trajectory) # assign disease status
pca1.0 <- glPca(gl1.0, nf=4, parallel=F) # nf = number of PC axes to retain (here, 4)
pca1.0 # prints summary
plot(pca1.0$scores[,1], pca1.0$scores[,2],
cex=2, pch=20, col=gl1.0$pop,
xlab="Principal Component 1",
ylab="Principal Component 2",
main="PCA on SSW data (Freq missing=15%; 2005 SNPs)")
plot(pca1.0$scores[,1], pca1.0$scores[,2],
cex=2, pch=20, col=gl1.0$pop,
xlab="Principal Component 1",
ylab="Principal Component 2",
main="PCA on SSW data (Freq missing=15%; 2005 SNPs)")
legend("topleft",
legend=unique(gl1.0$pop),
pch=20,
col=c("black", "red"))
plot(pca2.0$scores[,1], pca2.0$scores[,2],
cex=2, pch=20, col=gl2.0$pop,
xlab="Principal Component 1",
ylab="Principal Component 2",
main="PCA on SSW data (Freq missing=15%; 2005 SNPs)")
pca2.0 <- glPca(gl2.0, nf=4, parallel=F) # nf = number of PC axes to retain (here, 4)
pca2.0 # prints summary
plot(pca2.0$scores[,1], pca2.0$scores[,2],
cex=2, pch=20, col=gl2.0$pop,
xlab="Principal Component 1",
ylab="Principal Component 2",
main="PCA on SSW data (Freq missing=15%; 2005 SNPs)")
plot(pca2.0$scores[,1], pca2.0$scores[,2],
cex=2, pch=20, col=gl2.0$pop,
xlab="Principal Component 1",
ylab="Principal Component 2",
main="PCA on SSW data (Freq missing=15%; 2005 SNPs)")
legend("topleft",
legend=unique(gl2.0$pop),
pch=20,
col=c("black", "red"))
plot(pca2.0$scores[,1], pca2.0$scores[,2],
cex=2, pch=20, col=gl2.0$pop,
xlab="Principal Component 1",
ylab="Principal Component 2",
main="PCA on SSW data (Freq missing=15%; 1916 SNPs)")
legend("topleft",
legend=unique(gl2.0$pop),
pch=20,
col=c("black", "red"))
plot(pca2.0$scores[,1], pca2.0$scores[,2],
cex=2, pch=20, col=gl2.0$pop,
xlab="Principal Component 1",
ylab="Principal Component 2",
main="PCA on SSW data (Freq missing=15%; 1916 SNPs)")
legend("topleft",
legend=unique(gl2.0$pop),
pch=20,
col=c("black", "red"))
plot(pca1.0$scores[,1], pca1.0$scores[,2],
cex=2, pch=20, col=as.factor(gl1.0$other$Trajectory),
xlab="Principal Component 1",
ylab="Principal Component 2",
main="PCA on SSW data (Freq missing=15%; 2005 SNPs)")
plot(pca1.0$scores[,1], pca1.0$scores[,2],
cex=2, pch=20, col=as.factor(gl1.0$other$Trajectory),
xlab="Principal Component 1",
ylab="Principal Component 2",
main="PCA on SSW data (Freq missing=15%; 2005 SNPs)")
plot(pca1.0$scores[,1], pca1.0$scores[,2],
cex=2, pch=20, col=as.factor(gl1.0$other$Trajectory),
xlab="Principal Component 1",
ylab="Principal Component 2",
main="PCA on SSW data (Freq missing=15%; 2005 SNPs)")
pca1.0$scores[,1]
gl1.0$other$Trajectory
head(gl1.0)
ssw_meta$Trajectory
gl1.0$other$Trajectory
gl1.0$Trajectory
gl1.0$other
plot(pca1.0$scores[,1], pca1.0$scores[,2],
cex=2, pch=20, col=as.factor(gl1.0$other),
xlab="Principal Component 1",
ylab="Principal Component 2",
main="PCA on SSW data (Freq missing=15%; 2005 SNPs)")
plot(pca1.0$scores[,1], pca1.0$scores[,2],
cex=2, pch=20, col=as.factor(gl1.0$other),
xlab="Principal Component 1",
ylab="Principal Component 2",
main="PCA on SSW data (Freq missing=15%; 2005 SNPs)")
gl1.0$other <- as.list(ssw_meta$Trajectory) # assign disease status
gl1.0$other <- as.list(ssw_meta$Trajectory) # assign disease status
plot(pca1.0$scores[,1], pca1.0$scores[,2],
cex=2, pch=20, col=as.factor(gl1.0$other),
xlab="Principal Component 1",
ylab="Principal Component 2",
main="PCA on SSW data (Freq missing=15%; 2005 SNPs)")
str(gl1.0$other)
plot(pca1$scores[,1], pca1$scores[,2],
cex=2, pch=20, col=as.factor(ssw_meta$Trajectory),
xlab="Principal Component 1",
ylab="Principal Component 2",
main="PCA on SSW data (Freq missing=20%; 5317 SNPs)")
plot(pca1.0$scores[,1], pca1.0$scores[,2],
cex=2, pch=20, col=as.factor(ssw_meta$Trajectory),
xlab="Principal Component 1",
ylab="Principal Component 2",
main="PCA on SSW data (Freq missing=15%; 2005 SNPs)")
legend("topleft",
legend=unique(gl1.0$other$Trajectory),
pch=20,
col=as.factor(unique(gl1.0$other$Trajectory)))
plot(pca1.0$scores[,1], pca1.0$scores[,2],
cex=2, pch=20, col=as.factor(ssw_meta$Trajectory),
xlab="Principal Component 1",
ylab="Principal Component 2",
main="PCA on SSW data (Freq missing=15%; 2005 SNPs)")
plot(pca1.0$scores[,1], pca1.0$scores[,2],
cex=2, pch=20, col=as.factor(ssw_meta$Trajectory),
xlab="Principal Component 1",
ylab="Principal Component 2",
main="PCA on SSW data (Freq missing=15%; 2005 SNPs)")
legend("topleft",
legend=unique(ssw_meta$Trajectory),
pch=20,
col=as.factor(unique(ssw_meta$Trajectory)))
vcf1.0 <- read.vcfR("filteredSNPS1.0.recode.vcf")
vcf1.0 <- read.vcfR("filteredSNPS1.0.recode.vcf")
gl1.0 <- vcfR2genlight(vcf1.0)
ssw_meta <- read.table("ssw_healthloc.txt", header=T) # read in the metadata
ssw_meta <- ssw_meta[order(ssw_meta$Individual),] # sort it by Individual ID
gl1.0$ind.names
ssw_meta$Individual
gl1.0$pop <- ssw_meta$Location # assign locality info
gl1.0$other <- as.list(ssw_meta$Trajectory) # assign disease status
pca1.0 <- glPca(gl1.0, nf=4, parallel=F) # nf = number of PC axes to retain (here, 4)
pca1.0 # prints summary
plot(pca1.0$scores[,1], pca1.0$scores[,2],
cex=2, pch=20, col=gl1.0$pop,
xlab="Principal Component 1",
ylab="Principal Component 2",
main="PCA on SSW data (Freq missing=15%; 2005 SNPs)")
plot(pca1.0$scores[,1], pca1.0$scores[,2],
cex=2, pch=20, col=gl1.0$pop,
xlab="Principal Component 1",
ylab="Principal Component 2",
main="PCA on SSW data (Freq missing=15%; 2005 SNPs)")
legend("topleft",
legend=unique(gl1.0$pop),
pch=20,
col=c("black", "red"))
plot(pca1.0$scores[,1], pca1.0$scores[,2],
cex=2, pch=20, col=as.factor(ssw_meta$Trajectory),
xlab="Principal Component 1",
ylab="Principal Component 2",
main="PCA on SSW data (Freq missing=15%; 2005 SNPs)")
plot(pca1.0$scores[,1], pca1.0$scores[,2],
cex=2, pch=20, col=as.factor(ssw_meta$Trajectory),
xlab="Principal Component 1",
ylab="Principal Component 2",
main="PCA on SSW data (Freq missing=15%; 2005 SNPs)")
legend("topleft",
legend=unique(ssw_meta$Trajectory),
pch=20,
col=as.factor(unique(ssw_meta$Trajectory)))
plot(pca1.0$scores[,1], pca1.0$scores[,2],
cex=2, pch=20, col=as.factor(ssw_meta$Trajectory=="SS"&"HH"),
xlab="Principal Component 1",
ylab="Principal Component 2",
main="PCA on SSW data (Freq missing=15%; 2005 SNPs)")
plot(pca1.0$scores[,1], pca1.0$scores[,2],
cex=2, pch=20, col=as.factor(ssw_meta$Trajectory=="SS"&"HH"),
xlab="Principal Component 1",
ylab="Principal Component 2",
main="PCA on SSW data (Freq missing=15%; 2005 SNPs)")
plot(pca1.0$scores[,1], pca1.0$scores[,2],
cex=2, pch=20, col=as.factor(ssw_meta$Trajectory=="SS"&"HH"),
xlab="Principal Component 1",
ylab="Principal Component 2",
main="PCA on SSW data (Freq missing=15%; 2005 SNPs)")
pca1.0 # prints summary
pca1.0$loadings
pca1.0 # prints summary
summary(pca1.0)
plot(pca1.0$scores[,1], pca1.0$scores[,2],
cex=2, pch=20, col=as.factor(ssw_meta$Trajectory),
xlab="Principal Component 1",
ylab="Principal Component 2",
main="PCA on SSW data (Freq missing=15%; 2005 SNPs)")
legend("topleft",
legend=unique(ssw_meta$Trajectory),
pch=20,
col=as.factor(unique(ssw_meta$Trajectory)))
plot(pca2.0$scores[,1], pca2.0$scores[,2],
cex=2, pch=20, col=as.factor(ssw_meta$Trajectory),
xlab="Principal Component 1",
ylab="Principal Component 2",
main="PCA on SSW data (Freq missing=15%; 1916 SNPs)")
plot(pca2.0$scores[,1], pca2.0$scores[,2],
cex=2, pch=20, col=as.factor(ssw_meta$Trajectory),
xlab="Principal Component 1",
ylab="Principal Component 2",
main="PCA on SSW data (Freq missing=15%; 1916 SNPs)")
legend("topleft",
legend=unique(ssw_meta$Trajectory),
pch=20,
col=as.factor(unique(ssw_meta$Trajectory)))
loadingplot(abs(pca1.0$loadings[,1]),
threshold=quantile(abs(pca1.0$loadings), 0.999))
loadingplot(abs(pca1.0$loadings[,1]),
threshold=quantile(abs(pca1.0$loadings), 0.999))
gl1.0$loc.names[which(abs(pca1.0$loadings)>quantile(abs(pca1.0$loadings), 0.999))]
gl1.0$loc.names[which(abs(pca1.0$loadings)>quantile(abs(pca1.0$loadings), 0.999))]
loadingplot(abs(pca2.0$loadings[,1]),
threshold=quantile(abs(pca2.0$loadings), 0.999))
gl2.0$loc.names[which(abs(pca2.0$loadings)>quantile(abs(pca2.0$loadings), 0.999))]
gl2.0$loc.names[which(abs(pca2.0$loadings)>quantile(abs(pca2.0$loadings), 0.999))]
pca2.0 # prints summary
pca2.0$scores # prints summary
pca2.0$eig # prints summary
setwd("C:/Users/Lauren/Desktop/Gradschool/UVM/Spring 2017/Ecological Genomics/Annotation")
input="results_int_H0vsS1_neglogpval.csv" # two columns of comma-separated values: gene id, continuous measure of significance. To perform standard GO enrichment analysis based on Fisher's exact test, use binary measure (0 or 1, i.e., either sgnificant or not).
input="results_int_H0vsS1_neglogpval.csv" # two columns of comma-separated values: gene id, continuous measure of significance. To perform standard GO enrichment analysis based on Fisher's exact test, use binary measure (0 or 1, i.e., either sgnificant or not).
goAnnotations="annotation_table.tab" # two-column, tab-delimited, one line per gene, multiple GO terms separated by semicolon. If you have multiple lines per gene, use nrify_GOtable.pl prior to running this script.
goDatabase="go.obo" # download from http://www.geneontology.org/GO.downloads.ontology.shtml
goDivision="BP" # either MF, or BP, or CC
source("gomwu.functions.R")
gomwuStats(input, goDatabase, goAnnotations, goDivision,
perlPath="perl", # replace with full path to perl executable if it is not in your system's PATH already
largest=0.1,  # a GO category will not be considered if it contains more than this fraction of the total number of genes
smallest=5,   # a GO category should contain at least this many genes to be considered
clusterCutHeight=0.25, # threshold for merging similar (gene-sharing) terms.
#	Alternative="g" # by default the MWU test is two-tailed; specify "g" or "l" of you want to test for "greater" or "less" instead
)
gomwuStats(input, goDatabase, goAnnotations, goDivision,
perlPath="perl", # replace with full path to perl executable if it is not in your system's PATH already
largest=0.1,  # a GO category will not be considered if it contains more than this fraction of the total number of genes
smallest=5,   # a GO category should contain at least this many genes to be considered
clusterCutHeight=0.25, # threshold for merging similar (gene-sharing) terms.
#	Alternative="g" # by default the MWU test is two-tailed; specify "g" or "l" of you want to test for "greater" or "less" instead
)
gomwuStats(input, goDatabase, goAnnotations, goDivision,
perlPath="perl", # replace with full path to perl executable if it is not in your system's PATH already
largest=0.1,  # a GO category will not be considered if it contains more than this fraction of the total number of genes
smallest=5,   # a GO category should contain at least this many genes to be considered
clusterCutHeight=0.25) # threshold for merging similar (gene-sharing) terms.
gomwuStats(input, goDatabase, goAnnotations, goDivision,
perlPath="perl", # replace with full path to perl executable if it is not in your system's PATH already
largest=0.1,  # a GO category will not be considered if it contains more than this fraction of the total number of genes
smallest=5,   # a GO category should contain at least this many genes to be considered
clusterCutHeight=0.25,) # threshold for merging similar (gene-sharing) terms.
input="results_int_H0vsS1_neglogpval.csv" # two columns of comma-separated values: gene id, continuous measure of significance. To perform standard GO enrichment analysis based on Fisher's exact test, use binary measure (0 or 1, i.e., either sgnificant or not).
goAnnotations="annotation_table.tab" # two-column, tab-delimited, one line per gene, multiple GO terms separated by semicolon. If you have multiple lines per gene, use nrify_GOtable.pl prior to running this script.
goDatabase="go.obo" # download from http://www.geneontology.org/GO.downloads.ontology.shtml
goDivision="BP" # either MF, or BP, or CC
source("gomwu.functions.R")
gomwuStats(input, goDatabase, goAnnotations, goDivision,
perlPath="perl", # replace with full path to perl executable if it is not in your system's PATH already
largest=0.1,  # a GO category will not be considered if it contains more than this fraction of the total number of genes
smallest=5,   # a GO category should contain at least this many genes to be considered
clusterCutHeight=0.25,) # threshold for merging similar (gene-sharing) terms.
setwd("C:/Users/Lauren/Desktop/Gradschool/UVM/Spring 2017/Ecological Genomics")
setwd("C:/Users/Lauren/Desktop/Gradschool/UVM/Spring 2017/Computational Biology/Bio381/compbio")
myDat <- seq(from=0, to=3, by=1, length.out=15)
myDat <- rnorm(n=100, mean=0, sd=1)
myDat
myDat <- round(rnorm(n=100, mean=0, sd=1))
myDat
countVec <- rep(0,100)
countVec
myDat <- round(rnorm(n=100, mean=0, sd=1))
myDat
countVec <- rep(0,100)
countVec
countZero <- function(vector = myDat){
for(i in 1:length(myDat)){
if(countZero[i]==0){
countVec[i]<-1
}
else{countVec[i]<- 0}
}
return(sum(countVec))
}
countZero()
countZero <- function(vector = myDat){
for(i in 1:length(myDat)){
if(countZero[i]==0){
countVec[i]<-1
}
else{countVec[i]<- 0}
}
return(sum(countVec))
}
countVec
countVec <- vector(mode="numeric")
countVec
countZero <- function(vector = myDat){
for(i in 1:length(myDat)){
if(countZero[i]==0){
countVec[i]<-1
}
else{countVec[i]<- 0}
}
return(sum(countVec))
}
countZero()
countVec[1]
countZero
myDat <- round(rnorm(n=100, mean=0, sd=1))
myDat
countVec <- vector(mode="numeric")
countVec
countZero <- function(vector = myDat){
for(i in 1:length(myDat)){
if(myDat[i]==0){
countVec[i]<-1
}
else{countVec[i]<- 0}
}
return(sum(countVec))
}
countZero()
myDat <- round(rnorm(n=100, mean=0, sd=1))
myDat
countZero2.0 <- function(vector = myDat){
return(sum(myDat==0))
}
countZero2.0()
diffVec <- rnorm(n=100, mean=10, sd=2)
diffVec <- rnorm(n=100, mean=10, sd=2)
storeVec <- vector(mode="numeric")
pairDiff <- function(vector=diffVec){
for(i in 1:length(diffVec)){
storeVec  <- diffVec[i] - diffVec[i+(1:length(diffVec))]
return(max(storeVec))
}
}
pairDiff()
storeVec
diffVec <- rnorm(n=100, mean=10, sd=2)
storeVec <- vector(mode="numeric")
pairDiff <- function(vector=diffVec){
for(i in 1:length(diffVec)){
storeVec  <- diffVec[i] - seq(diffVec[i+1], length(diffVec))
#diffVec[i+(1:length(diffVec))]
return(max(storeVec))
}
}
storeVec
pairDiff()
diffVec <- c(5,10, 15,35)
storeVec <- vector(mode="numeric")
pairDiff <- function(vector=diffVec){
for(i in 1:length(diffVec)){
storeVec  <- diffVec[i] - seq(diffVec[i+1], length(diffVec))
#diffVec[i+(1:length(diffVec))]
return(max(storeVec))
}
}
pairDiff()
diffVec <- c(5,10, 15,35)
storeVec <- vector(mode="numeric")
pairDiff <- function(vector=diffVec){
storeVec<- abs(combn(x=vector, m=length(vector), FUN=diff))
return(max(storeVec))
}
pairDiff()
diffVec <- c(5,10, 15,35)
storeVec <- vector(mode="numeric")
pairDiff <- function(vector=diffVec){
storeVec<- combn(x=vector, m=length(vector), FUN=diff)
return(max(storeVec))
}
pairDiff()
diffVec <- c(5,10, 15,35)
storeVec <- vector(mode="numeric")
pairDiff <- function(vector=diffVec){
storeVec<- abs(combn(x=vector, m=length(vector), FUN=diff, simplify=FALSE))
return(max(storeVec))
}
pairDiff()
diffVec <- c(5,10, 15,35)
storeVec <- vector(mode="numeric")
pairDiff <- function(vector=diffVec){
storeVec<- abs(combn(x=vector, m=length(vector), FUN=diff))
return(max(storeVec))
}
pairDiff()
storeVec<- abs(combn(x=vector, m=length(vector), FUN=diff))
vec1 <- c(5,10,15,35)
storeVec<- abs(combn(x=vec1, m=length(vec1), FUN=diff))
storeVec
vec1 <- c(5,10,15,35)
storeVec<- abs(apply(combn(1:4,2), 2, diff))
storeVec
vec1 <- c(5,10,15,35)
storeVec<- abs(apply(combn(vec1,2), 2, diff))
storeVec
diffVec <- c(5,10, 15,35)
storeVec <- vector(mode="numeric")
pairDiff <- function(vector=diffVec){
storeVec<- abs(apply(combn(vec1,2), 2, diff))
return(max(storeVec))
}
pairDiff()
setwd("C:/Users/Lauren/Desktop/Gradschool/UVM/Spring 2017/Ecological Genomics")
library(adegenet)
library(vcfR)
vcf1.0 <- read.vcfR("filteredSNPS1.0.recode.vcf")
vcf2.0 <- read.vcfR("filteredSNPS2.0.recode.vcf")
gl1.0 <- vcfR2genlight(vcf1.0)
gl2.0 <- vcfR2genlight(vcf2.0)
ssw_meta <- read.table("ssw_healthloc.txt", header=T) # read in the metadata
ssw_meta <- ssw_meta[order(ssw_meta$Individual),] # sort it by Individual ID
gl1.0$pop <- ssw_meta$Location # assign locality info
gl1.0$other <- as.list(ssw_meta$Trajectory) # assign disease status
gl2.0$pop <- ssw_meta$Location # assign locality info
gl2.0$other <- as.list(ssw_meta$Trajectory) # assign disease status
pca1.0 <- glPca(gl1.0, nf=4, parallel=F) # nf = number of PC axes to retain (here, 4)
pca1.0 # prints summary
pca1.0$loadings
summary(pca1.0)
pca2.0 <- glPca(gl2.0, nf=4, parallel=F) # nf = number of PC axes to retain (here, 4)
pca2.0$eig # prints summary
plot(pca1.0$scores[,1], pca1.0$scores[,2],
cex=2, pch=20, col=gl1.0$pop,
xlab="Principal Component 1",
ylab="Principal Component 2",
main="PCA on SSW data (Freq missing=15%; 2005 SNPs)")
plot(pca1.0$scores[,1], pca1.0$scores[,2],
cex=2, pch=20, col=as.factor(ssw_meta$Trajectory),
xlab="Principal Component 1",
ylab="Principal Component 2",
main="PCA on SSW data (Freq missing=15%; 1945 SNPs)")
legend("topleft",
legend=unique(ssw_meta$Trajectory),
pch=20,
col=as.factor(unique(ssw_meta$Trajectory)))
plot(pca2.0$scores[,1], pca2.0$scores[,2],
cex=2, pch=20, col=as.factor(ssw_meta$Trajectory),
xlab="Principal Component 1",
ylab="Principal Component 2",
main="PCA on SSW data (Freq missing=15%; 1861 SNPs)")
legend("topleft",
legend=unique(ssw_meta$Trajectory),
pch=20,
col=as.factor(unique(ssw_meta$Trajectory)))
loadingplot(abs(pca1.0$loadings[,1]),
threshold=quantile(abs(pca1.0$loadings), 0.999))
gl1.0$loc.names[which(abs(pca1.0$loadings)>quantile(abs(pca1.0$loadings), 0.999))]
loadingplot(abs(pca1.0$loadings[,1]),
threshold=quantile(abs(pca1.0$loadings), 0.999), main="Loading Plot PCA 1.0")
loadingplot(abs(pca1.0$loadings[,1]),
threshold=quantile(abs(pca1.0$loadings), 0.999), main="Loading Plot PCA 1.0")
loadingplot(abs(pca2.0$loadings[,1]),
threshold=quantile(abs(pca2.0$loadings), 0.999), main="Loading Plot PCA 2.0")
gl2.0$loc.names[which(abs(pca2.0$loadings)>quantile(abs(pca2.0$loadings), 0.999))]
gl1.0$loc.names[which(abs(pca1.0$loadings)>quantile(abs(pca1.0$loadings), 0.999))]
gl2.0$loc.names[which(abs(pca2.0$loadings)>quantile(abs(pca2.0$loadings), 0.999))]
